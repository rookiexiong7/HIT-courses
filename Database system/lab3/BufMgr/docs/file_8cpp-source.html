<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BadgerDB: bufmgr/src/file.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>bufmgr/src/file.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00008"></a>00008 <span class="preprocessor">#include "file.h"</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;cstdio&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include "exceptions/file_exists_exception.h"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "exceptions/file_not_found_exception.h"</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "exceptions/file_open_exception.h"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "exceptions/invalid_page_exception.h"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include "file_iterator.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "page.h"</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="keyword">namespace </span>badgerdb {
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 File::StreamMap File::open_streams_;
<a name="l00027"></a>00027 File::CountMap File::open_counts_;
<a name="l00028"></a>00028 
<a name="l00029"></a><a class="code" href="classbadgerdb_1_1_file.html#1fb708b45103a606f189850d6bf83a0c">00029</a> <a class="code" href="classbadgerdb_1_1_file.html">File</a> <a class="code" href="classbadgerdb_1_1_file.html#1fb708b45103a606f189850d6bf83a0c">File::create</a>(<span class="keyword">const</span> std::string&amp; filename) {
<a name="l00030"></a>00030   <span class="keywordflow">return</span> <a class="code" href="classbadgerdb_1_1_file.html#600baaf77d18f39e51ae7473eca633c4">File</a>(filename, <span class="keyword">true</span> <span class="comment">/* create_new */</span>);
<a name="l00031"></a>00031 }
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="classbadgerdb_1_1_file.html#8462afdbd250c0a483ddfbde144c8732">00033</a> <a class="code" href="classbadgerdb_1_1_file.html">File</a> <a class="code" href="classbadgerdb_1_1_file.html#8462afdbd250c0a483ddfbde144c8732">File::open</a>(<span class="keyword">const</span> std::string&amp; filename) {
<a name="l00034"></a>00034   <span class="keywordflow">return</span> <a class="code" href="classbadgerdb_1_1_file.html#600baaf77d18f39e51ae7473eca633c4">File</a>(filename, <span class="keyword">false</span> <span class="comment">/* create_new */</span>);
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="classbadgerdb_1_1_file.html#1cc69467366badbd68021ac76a91190e">00037</a> <span class="keywordtype">void</span> <a class="code" href="classbadgerdb_1_1_file.html#1cc69467366badbd68021ac76a91190e">File::remove</a>(<span class="keyword">const</span> std::string&amp; filename) {
<a name="l00038"></a>00038   <span class="keywordflow">if</span> (!<a class="code" href="classbadgerdb_1_1_file.html#864d59b12302c26b14967bd1d3e520bd">exists</a>(filename)) {
<a name="l00039"></a>00039     <span class="keywordflow">throw</span> <a class="code" href="classbadgerdb_1_1_file_not_found_exception.html">FileNotFoundException</a>(filename);
<a name="l00040"></a>00040   }
<a name="l00041"></a>00041   <span class="keywordflow">if</span> (<a class="code" href="classbadgerdb_1_1_file.html#64836156a9bb5f81d2c2c4e6f3ada24d">isOpen</a>(filename)) {
<a name="l00042"></a>00042     <span class="keywordflow">throw</span> <a class="code" href="classbadgerdb_1_1_file_open_exception.html">FileOpenException</a>(filename);
<a name="l00043"></a>00043   }
<a name="l00044"></a>00044   std::remove(filename.c_str());
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="classbadgerdb_1_1_file.html#64836156a9bb5f81d2c2c4e6f3ada24d">00047</a> <span class="keywordtype">bool</span> <a class="code" href="classbadgerdb_1_1_file.html#64836156a9bb5f81d2c2c4e6f3ada24d">File::isOpen</a>(<span class="keyword">const</span> std::string&amp; filename) {
<a name="l00048"></a>00048   <span class="keywordflow">if</span> (!<a class="code" href="classbadgerdb_1_1_file.html#864d59b12302c26b14967bd1d3e520bd">exists</a>(filename)) {
<a name="l00049"></a>00049     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00050"></a>00050   }
<a name="l00051"></a>00051   <span class="keywordflow">return</span> open_counts_.find(filename) != open_counts_.end();
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="classbadgerdb_1_1_file.html#864d59b12302c26b14967bd1d3e520bd">00054</a> <span class="keywordtype">bool</span> <a class="code" href="classbadgerdb_1_1_file.html#864d59b12302c26b14967bd1d3e520bd">File::exists</a>(<span class="keyword">const</span> std::string&amp; filename) {
<a name="l00055"></a>00055   std::fstream file(filename);
<a name="l00056"></a>00056   <span class="keywordflow">if</span>(file)
<a name="l00057"></a>00057   {
<a name="l00058"></a>00058     file.close();
<a name="l00059"></a>00059     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00060"></a>00060   }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064 
<a name="l00065"></a><a class="code" href="classbadgerdb_1_1_file.html#600baaf77d18f39e51ae7473eca633c4">00065</a> <a class="code" href="classbadgerdb_1_1_file.html#600baaf77d18f39e51ae7473eca633c4">File::File</a>(<span class="keyword">const</span> <a class="code" href="classbadgerdb_1_1_file.html">File</a>&amp; other)
<a name="l00066"></a>00066   : filename_(other.filename_),
<a name="l00067"></a>00067     stream_(open_streams_[filename_]) {
<a name="l00068"></a>00068   ++open_counts_[filename_];
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="classbadgerdb_1_1_file.html#c403c631aec085e9f12992f260a57155">00071</a> <a class="code" href="classbadgerdb_1_1_file.html">File</a>&amp; <a class="code" href="classbadgerdb_1_1_file.html#c403c631aec085e9f12992f260a57155">File::operator=</a>(<span class="keyword">const</span> <a class="code" href="classbadgerdb_1_1_file.html">File</a>&amp; rhs) {
<a name="l00072"></a>00072   <span class="comment">// This accounts for self-assignment and assignment of a File object for the</span>
<a name="l00073"></a>00073   <span class="comment">// same file.</span>
<a name="l00074"></a>00074   close();  <span class="comment">//close my file and associate me with the new one</span>
<a name="l00075"></a>00075   filename_ = rhs.<a class="code" href="classbadgerdb_1_1_file.html#c06d54f377f44a1d7d2e905aba19c9e7">filename_</a>;
<a name="l00076"></a>00076   openIfNeeded(<span class="keyword">false</span> <span class="comment">/* create_new */</span>);
<a name="l00077"></a>00077   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="classbadgerdb_1_1_file.html#97fd6e3ae8dd11be883289b69d560287">00080</a> <a class="code" href="classbadgerdb_1_1_file.html#97fd6e3ae8dd11be883289b69d560287">File::~File</a>() {
<a name="l00081"></a>00081   close();
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a><a class="code" href="classbadgerdb_1_1_file.html#7d0e047bcc8dc4cee36aac5b2060bbe3">00084</a> <a class="code" href="classbadgerdb_1_1_page.html">Page</a> <a class="code" href="classbadgerdb_1_1_file.html#7d0e047bcc8dc4cee36aac5b2060bbe3">File::allocatePage</a>() {
<a name="l00085"></a>00085   <a class="code" href="structbadgerdb_1_1_file_header.html">FileHeader</a> header = readHeader();
<a name="l00086"></a>00086   <a class="code" href="classbadgerdb_1_1_page.html">Page</a> new_page;
<a name="l00087"></a>00087   <a class="code" href="classbadgerdb_1_1_page.html">Page</a> existing_page;
<a name="l00088"></a>00088   <span class="keywordflow">if</span> (header.<a class="code" href="structbadgerdb_1_1_file_header.html#07ac20f98d6aced3eb5358e0d4830abc">num_free_pages</a> &gt; 0) {
<a name="l00089"></a>00089     new_page = <a class="code" href="classbadgerdb_1_1_file.html#ba4762b533499b7b7cc0774192ead27c">readPage</a>(header.<a class="code" href="structbadgerdb_1_1_file_header.html#a86917d8554a42318c795471f32ad006">first_free_page</a>, <span class="keyword">true</span> <span class="comment">/* allow_free */</span>);
<a name="l00090"></a>00090     new_page.<a class="code" href="classbadgerdb_1_1_page.html#7156171ef07072b12667bd813237a461">set_page_number</a>(header.<a class="code" href="structbadgerdb_1_1_file_header.html#a86917d8554a42318c795471f32ad006">first_free_page</a>);
<a name="l00091"></a>00091     header.<a class="code" href="structbadgerdb_1_1_file_header.html#a86917d8554a42318c795471f32ad006">first_free_page</a> = new_page.<a class="code" href="classbadgerdb_1_1_page.html#8050c219873e6b1d51aec2adbea8a507">next_page_number</a>();
<a name="l00092"></a>00092     --header.<a class="code" href="structbadgerdb_1_1_file_header.html#07ac20f98d6aced3eb5358e0d4830abc">num_free_pages</a>;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> == <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a> ||
<a name="l00095"></a>00095         header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> &gt; new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>()) {
<a name="l00096"></a>00096       <span class="comment">// Either have no pages used or the head of the used list is a page later</span>
<a name="l00097"></a>00097       <span class="comment">// than the one we just allocated, so add the new page to the head.</span>
<a name="l00098"></a>00098       <span class="keywordflow">if</span> (header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> &gt; new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>()) {
<a name="l00099"></a>00099         new_page.<a class="code" href="classbadgerdb_1_1_page.html#9b17a27b9f6959f2d36b910dd4c62704">set_next_page_number</a>(header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a>);
<a name="l00100"></a>00100       }
<a name="l00101"></a>00101       header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> = new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>();
<a name="l00102"></a>00102     } <span class="keywordflow">else</span> {
<a name="l00103"></a>00103       <span class="comment">// New page is reused from somewhere after the beginning, so we need to</span>
<a name="l00104"></a>00104       <span class="comment">// find where in the used list to insert it.</span>
<a name="l00105"></a>00105       <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> next_page_number = <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>;
<a name="l00106"></a>00106       <span class="keywordflow">for</span> (<a class="code" href="classbadgerdb_1_1_file_iterator.html">FileIterator</a> iter = <a class="code" href="classbadgerdb_1_1_file.html#32e94f392eb3740dd9eb9101b9e09d47">begin</a>(); iter != <a class="code" href="classbadgerdb_1_1_file.html#01e224676a67634f21d53fc4189b8f11">end</a>(); ++iter) {
<a name="l00107"></a>00107         next_page_number = (*iter).next_page_number();
<a name="l00108"></a>00108         <span class="keywordflow">if</span> (next_page_number &gt; new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>() ||
<a name="l00109"></a>00109             next_page_number == <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>) {
<a name="l00110"></a>00110           existing_page = *iter;
<a name="l00111"></a>00111           <span class="keywordflow">break</span>;
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113       }
<a name="l00114"></a>00114       existing_page.<a class="code" href="classbadgerdb_1_1_page.html#9b17a27b9f6959f2d36b910dd4c62704">set_next_page_number</a>(new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>());
<a name="l00115"></a>00115       new_page.<a class="code" href="classbadgerdb_1_1_page.html#9b17a27b9f6959f2d36b910dd4c62704">set_next_page_number</a>(next_page_number);
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     assert((header.<a class="code" href="structbadgerdb_1_1_file_header.html#07ac20f98d6aced3eb5358e0d4830abc">num_free_pages</a> == 0) ==
<a name="l00119"></a>00119            (header.<a class="code" href="structbadgerdb_1_1_file_header.html#a86917d8554a42318c795471f32ad006">first_free_page</a> == <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>));
<a name="l00120"></a>00120   } <span class="keywordflow">else</span> {
<a name="l00121"></a>00121     new_page.<a class="code" href="classbadgerdb_1_1_page.html#7156171ef07072b12667bd813237a461">set_page_number</a>(header.<a class="code" href="structbadgerdb_1_1_file_header.html#a1cfc5220c6795868c8301cec298c8a6">num_pages</a>);
<a name="l00122"></a>00122     <span class="keywordflow">if</span> (header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> == <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>) {
<a name="l00123"></a>00123       header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> = new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>();
<a name="l00124"></a>00124     } <span class="keywordflow">else</span> {
<a name="l00125"></a>00125       <span class="comment">// If we have pages allocated, we need to add the new page to the tail</span>
<a name="l00126"></a>00126       <span class="comment">// of the linked list.</span>
<a name="l00127"></a>00127       <span class="keywordflow">for</span> (<a class="code" href="classbadgerdb_1_1_file_iterator.html">FileIterator</a> iter = <a class="code" href="classbadgerdb_1_1_file.html#32e94f392eb3740dd9eb9101b9e09d47">begin</a>(); iter != <a class="code" href="classbadgerdb_1_1_file.html#01e224676a67634f21d53fc4189b8f11">end</a>(); ++iter) {
<a name="l00128"></a>00128         <span class="keywordflow">if</span> ((*iter).next_page_number() == <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>) {
<a name="l00129"></a>00129           existing_page = *iter;
<a name="l00130"></a>00130           <span class="keywordflow">break</span>;
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132       }
<a name="l00133"></a>00133       assert(existing_page.<a class="code" href="classbadgerdb_1_1_page.html#236e6e8c2767de0332693b60ba9059d1">isUsed</a>());
<a name="l00134"></a>00134       existing_page.<a class="code" href="classbadgerdb_1_1_page.html#9b17a27b9f6959f2d36b910dd4c62704">set_next_page_number</a>(new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>());
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136     ++header.<a class="code" href="structbadgerdb_1_1_file_header.html#a1cfc5220c6795868c8301cec298c8a6">num_pages</a>;
<a name="l00137"></a>00137   }
<a name="l00138"></a>00138   <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">writePage</a>(new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>(), new_page);
<a name="l00139"></a>00139   <span class="keywordflow">if</span> (existing_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>() != <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>) {
<a name="l00140"></a>00140     <span class="comment">// If we updated an existing page by inserting the new page into the</span>
<a name="l00141"></a>00141     <span class="comment">// used list, we need to write it out.</span>
<a name="l00142"></a>00142     <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">writePage</a>(existing_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>(), existing_page);
<a name="l00143"></a>00143   }
<a name="l00144"></a>00144   writeHeader(header);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="keywordflow">return</span> new_page;
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a><a class="code" href="classbadgerdb_1_1_file.html#ba4762b533499b7b7cc0774192ead27c">00149</a> <a class="code" href="classbadgerdb_1_1_page.html">Page</a> <a class="code" href="classbadgerdb_1_1_file.html#ba4762b533499b7b7cc0774192ead27c">File::readPage</a>(<span class="keyword">const</span> <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> page_number)<span class="keyword"> const </span>{
<a name="l00150"></a>00150   <a class="code" href="structbadgerdb_1_1_file_header.html">FileHeader</a> header = readHeader();
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (page_number &gt;= header.<a class="code" href="structbadgerdb_1_1_file_header.html#a1cfc5220c6795868c8301cec298c8a6">num_pages</a>) {
<a name="l00152"></a>00152     <span class="keywordflow">throw</span> <a class="code" href="classbadgerdb_1_1_invalid_page_exception.html">InvalidPageException</a>(page_number, filename_);
<a name="l00153"></a>00153   }
<a name="l00154"></a>00154   <span class="keywordflow">return</span> <a class="code" href="classbadgerdb_1_1_file.html#ba4762b533499b7b7cc0774192ead27c">readPage</a>(page_number, <span class="keyword">false</span> <span class="comment">/* allow_free */</span>);
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <a class="code" href="classbadgerdb_1_1_page.html">Page</a> <a class="code" href="classbadgerdb_1_1_file.html#ba4762b533499b7b7cc0774192ead27c">File::readPage</a>(<span class="keyword">const</span> <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> page_number, <span class="keyword">const</span> <span class="keywordtype">bool</span> allow_free)<span class="keyword"> const </span>{
<a name="l00158"></a>00158   <a class="code" href="classbadgerdb_1_1_page.html">Page</a> page;
<a name="l00159"></a>00159   stream_-&gt;seekg(pagePosition(page_number), std::ios::beg);
<a name="l00160"></a>00160   stream_-&gt;read(reinterpret_cast&lt;char*&gt;(&amp;page.<a class="code" href="classbadgerdb_1_1_page.html#5ab6420ced3e20d08eb807db77437d7f">header_</a>), <span class="keyword">sizeof</span>(page.<a class="code" href="classbadgerdb_1_1_page.html#5ab6420ced3e20d08eb807db77437d7f">header_</a>));
<a name="l00161"></a>00161   stream_-&gt;read(reinterpret_cast&lt;char*&gt;(&amp;page.<a class="code" href="classbadgerdb_1_1_page.html#7d2b763a9097e7b4043960bacbde1621">data_</a>[0]), <a class="code" href="classbadgerdb_1_1_page.html#74057ec71412352ef0aa5913bbebed25">Page::DATA_SIZE</a>);
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (!allow_free &amp;&amp; !page.<a class="code" href="classbadgerdb_1_1_page.html#236e6e8c2767de0332693b60ba9059d1">isUsed</a>()) {
<a name="l00163"></a>00163     <span class="keywordflow">throw</span> <a class="code" href="classbadgerdb_1_1_invalid_page_exception.html">InvalidPageException</a>(page_number, filename_);
<a name="l00164"></a>00164   }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <span class="keywordflow">return</span> page;
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">00169</a> <span class="keywordtype">void</span> <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">File::writePage</a>(<span class="keyword">const</span> <a class="code" href="classbadgerdb_1_1_page.html">Page</a>&amp; new_page) {
<a name="l00170"></a>00170   <a class="code" href="structbadgerdb_1_1_page_header.html">PageHeader</a> header = readPageHeader(new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>());
<a name="l00171"></a>00171   <span class="keywordflow">if</span> (header.<a class="code" href="structbadgerdb_1_1_page_header.html#3f721c5ce9ef491fdc9d12292f2f4498">current_page_number</a> == <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>) {
<a name="l00172"></a>00172     <span class="comment">// Page has been deleted since it was read.</span>
<a name="l00173"></a>00173     <span class="keywordflow">throw</span> <a class="code" href="classbadgerdb_1_1_invalid_page_exception.html">InvalidPageException</a>(new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>(), filename_);
<a name="l00174"></a>00174   }
<a name="l00175"></a>00175   <span class="comment">// Page on disk may have had its next page pointer updated since it was read;</span>
<a name="l00176"></a>00176   <span class="comment">// we don't modify that, but we do keep all the other modifications to the</span>
<a name="l00177"></a>00177   <span class="comment">// page header.</span>
<a name="l00178"></a>00178   <span class="keyword">const</span> <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> next_page_number = header.<a class="code" href="structbadgerdb_1_1_page_header.html#7cb8260dedb0748d3d75c4b1722dcf3c">next_page_number</a>;
<a name="l00179"></a>00179   header = new_page.<a class="code" href="classbadgerdb_1_1_page.html#5ab6420ced3e20d08eb807db77437d7f">header_</a>;
<a name="l00180"></a>00180   header.<a class="code" href="structbadgerdb_1_1_page_header.html#7cb8260dedb0748d3d75c4b1722dcf3c">next_page_number</a> = next_page_number;
<a name="l00181"></a>00181   <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">writePage</a>(new_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>(), header, new_page);
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="classbadgerdb_1_1_file.html#829a68ccfbeb0c9f66f3a2db7e0b99fe">00184</a> <span class="keywordtype">void</span> <a class="code" href="classbadgerdb_1_1_file.html#829a68ccfbeb0c9f66f3a2db7e0b99fe">File::deletePage</a>(<span class="keyword">const</span> <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> page_number) {
<a name="l00185"></a>00185   <a class="code" href="structbadgerdb_1_1_file_header.html">FileHeader</a> header = readHeader();
<a name="l00186"></a>00186   <a class="code" href="classbadgerdb_1_1_page.html">Page</a> existing_page = <a class="code" href="classbadgerdb_1_1_file.html#ba4762b533499b7b7cc0774192ead27c">readPage</a>(page_number);
<a name="l00187"></a>00187   <a class="code" href="classbadgerdb_1_1_page.html">Page</a> previous_page;
<a name="l00188"></a>00188   <span class="comment">// If this page is the head of the used list, update the header to point to</span>
<a name="l00189"></a>00189   <span class="comment">// the next page in line.</span>
<a name="l00190"></a>00190   <span class="keywordflow">if</span> (page_number == header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a>) {
<a name="l00191"></a>00191     header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a> = existing_page.<a class="code" href="classbadgerdb_1_1_page.html#8050c219873e6b1d51aec2adbea8a507">next_page_number</a>();
<a name="l00192"></a>00192   } <span class="keywordflow">else</span> {
<a name="l00193"></a>00193     <span class="comment">// Walk the used list so we can update the page that points to this one.</span>
<a name="l00194"></a>00194     <span class="keywordflow">for</span> (<a class="code" href="classbadgerdb_1_1_file_iterator.html">FileIterator</a> iter = <a class="code" href="classbadgerdb_1_1_file.html#32e94f392eb3740dd9eb9101b9e09d47">begin</a>(); iter != <a class="code" href="classbadgerdb_1_1_file.html#01e224676a67634f21d53fc4189b8f11">end</a>(); ++iter) {
<a name="l00195"></a>00195       previous_page = *iter;
<a name="l00196"></a>00196       <span class="keywordflow">if</span> (previous_page.<a class="code" href="classbadgerdb_1_1_page.html#8050c219873e6b1d51aec2adbea8a507">next_page_number</a>() == existing_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>()) {
<a name="l00197"></a>00197         previous_page.<a class="code" href="classbadgerdb_1_1_page.html#9b17a27b9f6959f2d36b910dd4c62704">set_next_page_number</a>(existing_page.<a class="code" href="classbadgerdb_1_1_page.html#8050c219873e6b1d51aec2adbea8a507">next_page_number</a>());
<a name="l00198"></a>00198         <span class="keywordflow">break</span>;
<a name="l00199"></a>00199       }
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201   }
<a name="l00202"></a>00202   <span class="comment">// Clear the page and add it to the head of the free list.</span>
<a name="l00203"></a>00203   existing_page.<a class="code" href="classbadgerdb_1_1_page.html#55ee9b54b573895c019cf00dd8b83b68">initialize</a>();
<a name="l00204"></a>00204   existing_page.<a class="code" href="classbadgerdb_1_1_page.html#9b17a27b9f6959f2d36b910dd4c62704">set_next_page_number</a>(header.<a class="code" href="structbadgerdb_1_1_file_header.html#a86917d8554a42318c795471f32ad006">first_free_page</a>);
<a name="l00205"></a>00205   header.<a class="code" href="structbadgerdb_1_1_file_header.html#a86917d8554a42318c795471f32ad006">first_free_page</a> = page_number;
<a name="l00206"></a>00206   ++header.<a class="code" href="structbadgerdb_1_1_file_header.html#07ac20f98d6aced3eb5358e0d4830abc">num_free_pages</a>;
<a name="l00207"></a>00207   <span class="keywordflow">if</span> (previous_page.<a class="code" href="classbadgerdb_1_1_page.html#236e6e8c2767de0332693b60ba9059d1">isUsed</a>()) {
<a name="l00208"></a>00208     <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">writePage</a>(previous_page.<a class="code" href="classbadgerdb_1_1_page.html#f55a0b44876bff4d513bdbed8bc8c5a3">page_number</a>(), previous_page);
<a name="l00209"></a>00209   }
<a name="l00210"></a>00210   <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">writePage</a>(page_number, existing_page);
<a name="l00211"></a>00211   writeHeader(header);
<a name="l00212"></a>00212 }
<a name="l00213"></a>00213 
<a name="l00214"></a><a class="code" href="classbadgerdb_1_1_file.html#32e94f392eb3740dd9eb9101b9e09d47">00214</a> <a class="code" href="classbadgerdb_1_1_file_iterator.html">FileIterator</a> <a class="code" href="classbadgerdb_1_1_file.html#32e94f392eb3740dd9eb9101b9e09d47">File::begin</a>() {
<a name="l00215"></a>00215   <span class="keyword">const</span> <a class="code" href="structbadgerdb_1_1_file_header.html">FileHeader</a>&amp; header = readHeader();
<a name="l00216"></a>00216   <span class="keywordflow">return</span> <a class="code" href="classbadgerdb_1_1_file.html#3cd56c83d638b63a676ae3c4b51dc1b2">FileIterator</a>(<span class="keyword">this</span>, header.<a class="code" href="structbadgerdb_1_1_file_header.html#d006b5b9d02b8c20e7ad5226680779c6">first_used_page</a>);
<a name="l00217"></a>00217 }
<a name="l00218"></a>00218 
<a name="l00219"></a><a class="code" href="classbadgerdb_1_1_file.html#01e224676a67634f21d53fc4189b8f11">00219</a> <a class="code" href="classbadgerdb_1_1_file_iterator.html">FileIterator</a> <a class="code" href="classbadgerdb_1_1_file.html#01e224676a67634f21d53fc4189b8f11">File::end</a>() {
<a name="l00220"></a>00220   <span class="keywordflow">return</span> <a class="code" href="classbadgerdb_1_1_file.html#3cd56c83d638b63a676ae3c4b51dc1b2">FileIterator</a>(<span class="keyword">this</span>, <a class="code" href="classbadgerdb_1_1_page.html#785a1e756d47fb7f8f3603a3fe8ffcef">Page::INVALID_NUMBER</a>);
<a name="l00221"></a>00221 }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <a class="code" href="classbadgerdb_1_1_file.html#600baaf77d18f39e51ae7473eca633c4">File::File</a>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <span class="keywordtype">bool</span> create_new) : filename_(name) {
<a name="l00224"></a>00224   openIfNeeded(create_new);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="keywordflow">if</span> (create_new) {
<a name="l00227"></a>00227     <span class="comment">// File starts with 1 page (the header).</span>
<a name="l00228"></a>00228     <a class="code" href="structbadgerdb_1_1_file_header.html">FileHeader</a> header = {1 <span class="comment">/* num_pages */</span>, 0 <span class="comment">/* first_used_page */</span>,
<a name="l00229"></a>00229                          0 <span class="comment">/* num_free_pages */</span>, 0 <span class="comment">/* first_free_page */</span>};
<a name="l00230"></a>00230     writeHeader(header);
<a name="l00231"></a>00231   }
<a name="l00232"></a>00232 }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="keywordtype">void</span> File::openIfNeeded(<span class="keyword">const</span> <span class="keywordtype">bool</span> create_new) {
<a name="l00235"></a>00235   <span class="keywordflow">if</span> (open_counts_.find(filename_) != open_counts_.end()) { <span class="comment">//exists an entry already</span>
<a name="l00236"></a>00236     ++open_counts_[filename_];
<a name="l00237"></a>00237     stream_ = open_streams_[filename_];
<a name="l00238"></a>00238   } <span class="keywordflow">else</span> {
<a name="l00239"></a>00239     std::ios_base::openmode mode =
<a name="l00240"></a>00240         std::fstream::in | std::fstream::out | std::fstream::binary;
<a name="l00241"></a>00241     <span class="keyword">const</span> <span class="keywordtype">bool</span> already_exists = <a class="code" href="classbadgerdb_1_1_file.html#864d59b12302c26b14967bd1d3e520bd">exists</a>(filename_);
<a name="l00242"></a>00242     <span class="keywordflow">if</span> (create_new) {
<a name="l00243"></a>00243       <span class="comment">// Error if we try to overwrite an existing file.</span>
<a name="l00244"></a>00244       <span class="keywordflow">if</span> (already_exists) {
<a name="l00245"></a>00245         <span class="keywordflow">throw</span> FileExistsException(filename_);
<a name="l00246"></a>00246       }
<a name="l00247"></a>00247       <span class="comment">// New files have to be truncated on open.</span>
<a name="l00248"></a>00248       mode = mode | std::fstream::trunc;
<a name="l00249"></a>00249     } <span class="keywordflow">else</span> {
<a name="l00250"></a>00250       <span class="comment">// Error if we try to open a file that doesn't exist.</span>
<a name="l00251"></a>00251       <span class="keywordflow">if</span> (!already_exists) {
<a name="l00252"></a>00252         <span class="keywordflow">throw</span> FileNotFoundException(filename_);
<a name="l00253"></a>00253       }
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     stream_.reset(<span class="keyword">new</span> std::fstream(filename_, mode));
<a name="l00256"></a>00256     open_streams_[filename_] = stream_;
<a name="l00257"></a>00257     open_counts_[filename_] = 1;
<a name="l00258"></a>00258   }
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="keywordtype">void</span> File::close() {
<a name="l00262"></a>00262   --open_counts_[filename_];
<a name="l00263"></a>00263   stream_.reset();
<a name="l00264"></a>00264   <span class="keywordflow">if</span> (open_counts_[filename_] == 0) {
<a name="l00265"></a>00265     open_streams_.erase(filename_);
<a name="l00266"></a>00266     open_counts_.erase(filename_);
<a name="l00267"></a>00267   }
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="keywordtype">void</span> <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">File::writePage</a>(<span class="keyword">const</span> <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> page_number, <span class="keyword">const</span> Page&amp; new_page) {
<a name="l00271"></a>00271   <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">writePage</a>(page_number, new_page.header_, new_page);
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="keywordtype">void</span> <a class="code" href="classbadgerdb_1_1_file.html#9a1b3cc43c4631bde58c1c4f670e1036">File::writePage</a>(<span class="keyword">const</span> <a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> page_number, <span class="keyword">const</span> PageHeader&amp; header,
<a name="l00275"></a>00275                      <span class="keyword">const</span> Page&amp; new_page) {
<a name="l00276"></a>00276   stream_-&gt;seekp(pagePosition(page_number), std::ios::beg);
<a name="l00277"></a>00277   stream_-&gt;write(reinterpret_cast&lt;const char*&gt;(&amp;header), <span class="keyword">sizeof</span>(header));
<a name="l00278"></a>00278   stream_-&gt;write(reinterpret_cast&lt;const char*&gt;(&amp;new_page.data_[0]),
<a name="l00279"></a>00279                  <a class="code" href="classbadgerdb_1_1_page.html#74057ec71412352ef0aa5913bbebed25">Page::DATA_SIZE</a>);
<a name="l00280"></a>00280   stream_-&gt;flush();
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 FileHeader File::readHeader()<span class="keyword"> const </span>{
<a name="l00284"></a>00284   FileHeader header;
<a name="l00285"></a>00285   stream_-&gt;seekg(0 <span class="comment">/* pos */</span>, std::ios::beg);
<a name="l00286"></a>00286   stream_-&gt;read(reinterpret_cast&lt;char*&gt;(&amp;header), <span class="keyword">sizeof</span>(header));
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordflow">return</span> header;
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keywordtype">void</span> File::writeHeader(<span class="keyword">const</span> FileHeader&amp; header) {
<a name="l00292"></a>00292   stream_-&gt;seekp(0 <span class="comment">/* pos */</span>, std::ios::beg);
<a name="l00293"></a>00293   stream_-&gt;write(reinterpret_cast&lt;const char*&gt;(&amp;header), <span class="keyword">sizeof</span>(header));
<a name="l00294"></a>00294   stream_-&gt;flush();
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 PageHeader File::readPageHeader(<a class="code" href="namespacebadgerdb.html#1f49e404293bf4240756b89b53b1587a">PageId</a> page_number)<span class="keyword"> const </span>{
<a name="l00298"></a>00298   PageHeader header;
<a name="l00299"></a>00299   stream_-&gt;seekg(pagePosition(page_number), std::ios::beg);
<a name="l00300"></a>00300   stream_-&gt;read(reinterpret_cast&lt;char*&gt;(&amp;header), <span class="keyword">sizeof</span>(header));
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   <span class="keywordflow">return</span> header;
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 8 13:50:25 2012 for BadgerDB by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
